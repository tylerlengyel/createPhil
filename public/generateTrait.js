// generateTrait.js

// Mapping of trait names to their module file paths.
const traitModules = {
  bg: '/traitGeneration/bgTrait.js',
  color: '/traitGeneration/colorTrait.js',
  eyes: '/traitGeneration/eyesTrait.js',
  nose: '/traitGeneration/noseTrait.js',
  phil: '/traitGeneration/philTrait.js',
  spikes: '/traitGeneration/spikesTrait.js',
  teeth: '/traitGeneration/teethTrait.js',
  top: '/traitGeneration/topTrait.js',
  wings: '/traitGeneration/wingsTrait.js'
};

/**
 * Dynamically imports the module for the given trait and calls its generateTrait function.
 * It is assumed that each trait module exports a function named `generateTrait`
 * that returns (or resolves to) an SVG string.
 *
 * @param {string} trait - The trait identifier (e.g., 'wings', 'bg', etc.).
 * @returns {Promise<string>} - A promise that resolves to the SVG string.
 */
async function generateTraitSVG(trait) {
  const modulePath = traitModules[trait];
  if (!modulePath) {
    console.error('Module not found for trait:', trait);
    return '';
  }
  try {
    const module = await import(modulePath);
    if (typeof module.generateTrait === 'function') {
      return await module.generateTrait();
    } else {
      console.error(`Module ${modulePath} does not export a generateTrait function.`);
    }
  } catch (err) {
    console.error('Error importing module', modulePath, err);
  }
  return '';
}

document.addEventListener("DOMContentLoaded", function() {
  let currentTrait = "bg";

  // Get references to the DOM elements.
  const previewDiv = document.getElementById("preview");
  const traitTitle = document.getElementById("trait-title");
  const nextBtn = document.getElementById("next-btn");
  const saveBtn = document.getElementById("save-btn");
  const tabs = document.querySelectorAll(".tab");

  // Updates the preview area with the SVG generated by the current trait module.
  async function updatePreview() {
    previewDiv.innerHTML = '<p>Generating...</p>';
    const svg = await generateTraitSVG(currentTrait);
    if (svg) {
      previewDiv.innerHTML = svg;
    } else {
      previewDiv.innerHTML = '<p>Error generating SVG.</p>';
    }
  }

  // Tab click handling.
  tabs.forEach(tab => {
    tab.addEventListener("click", function() {
      // Remove the active class from all tabs.
      tabs.forEach(t => t.classList.remove("active"));
      // Mark the clicked tab as active.
      this.classList.add("active");
      // Set the current trait.
      currentTrait = this.getAttribute("data-trait");
      traitTitle.textContent = `${this.textContent} Trait`;
      updatePreview();
    });
  });

  // "Next" button to generate a new SVG for the current trait.
  nextBtn.addEventListener("click", function() {
    updatePreview();
  });

  // "Save" button to send the generated SVG to the server.
  saveBtn.addEventListener("click", function() {
    const svgData = previewDiv.innerHTML;
    
    fetch('/save-trait', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ trait: currentTrait, svg: svgData })
    })
    .then(response => response.json())
    .then(data => {
      if (data.error) {
        alert("Error saving file: " + data.error);
      } else {
        alert("File saved as: " + data.filename);
      }
    })
    .catch(err => {
      console.error(err);
      alert("Error saving file");
    });
  });

  // Generate the initial trait on page load.
  updatePreview();
});